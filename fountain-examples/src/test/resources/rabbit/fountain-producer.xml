<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
    xmlns:aop="http://www.springframework.org/schema/aop" xmlns:context="http://www.springframework.org/schema/context"
    xmlns:mvc="http://www.springframework.org/schema/mvc" xmlns:tx="http://www.springframework.org/schema/tx"
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    xsi:schemaLocation="http://www.springframework.org/schema/aop   
        http://www.springframework.org/schema/aop/spring-aop-3.1.xsd   
        http://www.springframework.org/schema/beans   
        http://www.springframework.org/schema/beans/spring-beans-3.1.xsd   
        http://www.springframework.org/schema/context   
        http://www.springframework.org/schema/context/spring-context-3.1.xsd   
        http://www.springframework.org/schema/mvc   
        http://www.springframework.org/schema/mvc/spring-mvc-3.1.xsd   
        http://www.springframework.org/schema/tx   
        http://www.springframework.org/schema/tx/spring-tx-3.1.xsd">
    <description>Spring公共配置</description>
    <bean
        class="org.springframework.aop.aspectj.annotation.AnnotationAwareAspectJAutoProxyCreator">
    </bean>

    <bean id="producerConfig"
        class="org.springframework.beans.factory.config.PropertyPlaceholderConfigurer">
        <property name="systemPropertiesModeName" value="SYSTEM_PROPERTIES_MODE_OVERRIDE" />
        <property name="ignoreResourceNotFound" value="true" />
        <property name="ignoreUnresolvablePlaceholders" value="true" />
        <property name="locations">
            <list>
                <value>classpath:rabbit/producer-related.properties</value>
                <value>classpath:rabbit/jdbc-mysql.properties</value>
                <value>classpath:rabbit/filter.properties</value>
            </list>
        </property>
    </bean>

    <aop:aspectj-autoproxy />

    <!-- 根据global transaction id得到对应的Binlog file name和position -->
    <bean id="groupExtender"
        class="net.neoremind.fountain.producer.datasource.eventpositionext.GtId2BinPositionEventPositionExtender" />
    <!-- 基于表名的匹配器,支持黑白名单,支持正则.符合匹配条件的event会被继续处理。用户可以实现EventMatcher接口,定制匹配 -->
    <bean id="shardTableMatcher" class="net.neoremind.fountain.producer.matcher.TableMatcher">
        <property name="tableWhite" value="${filter_shard_table_white}"></property>
        <property name="tableBlack" value="${filter_shard_table_black}"></property>
    </bean>
    <!-- row base binlog 解析器 -->
    <bean id="defaultParser"
        class="net.neoremind.fountain.producer.parser.impl.DefaultParser"
        scope="prototype">
        <constructor-arg ref="shardTableMatcher" />
    </bean>
    <!-- 对 memq起作用,用于保存在消费时保存gt id,但即使使用其他传输器时也不要删除该对象 -->
    <bean id="disposeEventPositionBridge"
        class="net.neoremind.fountain.eventposition.DisposeEventPositionBridgeImpl"></bean>
    <!-- 事务策略 -->
    <bean id="miniransPolicy"
        class="net.neoremind.fountain.producer.dispatch.transcontrol.MiniTransactionPolicy"
        scope="prototype">
        <!-- 事务数据的最大值,配置单位为记录条数，超出这个最大值就丢弃事务，缺省30000 -->
        <property name="maxTransSize" value="${trans_max_size}"></property>
    </bean>


    <!-- 记录已处理事件的位置,当fountain重新启动,切换master时会从该位置继续, 缺省实现使用文件保存,以global transaction 
        id表述位置,用户可以实现DisposeEventPosition接口 定制自己的存储方式或位置表述 -->
    <bean id="disposeEventPosition"
        class="net.neoremind.fountain.eventposition.ReadonlyDisposeEventPosition"
        scope="prototype">
        <property name="delegate">
            <bean
                class="net.neoremind.fountain.eventposition.DelayGroupIdDisposeEventPosition"
                scope="prototype">
                <property name="delegate">
                    <bean
                        class="net.neoremind.fountain.eventposition.LocalFileDisposeEventPosition"
                        scope="prototype">
                        <property name="rootPath" value="${producer_position}"></property>
                    </bean>
                </property>
                <property name="disposeEventPositionBridge"
                    ref="disposeEventPositionBridge"></property>
            </bean>
        </property>
    </bean>
    <bean id="fountainMQ"
        class="net.neoremind.fountain.common.mq.MultiPermitsMemFountainMQ">
        <constructor-arg index="0">
            <value>${memq_limit}</value>
        </constructor-arg>
    </bean>
    <bean id="memqTransport"
        class="net.neoremind.fountain.producer.dispatch.fountainmq.FoutainMQTransport">
        <property name="messageSeparationPolicy">
            <!-- 切割大事务 -->
            <bean
                class="net.neoremind.fountain.producer.dispatch.misc.BigChangeDataSetMessageSeparationPolicy">
                <property name="maxSubSize" value="${sparate_packsize}"></property>
            </bean>
        </property>
        <property name="fmq" ref="fountainMQ" />
    </bean>

    <!-- 变化的数据的下发流程,包括转换、序列化、和传输 -->
    <bean id="dispatchWorkflow"
        class="net.neoremind.fountain.producer.dispatch.DefaultDispatchWorkflow">
        <!-- 转化ChangeDataSet对象到其他的java对象的转化器,用户可以实现EventConverter接口定制转化器,以期转化为对用户更为友好的java对象 
            缺省是DefaultEventConverter,它不做任何转化,直接输出ChangeDataSet -->
        <!-- 配置数据传输层 -->
        <property name="tranport" ref="memqTransport" />
    </bean>
    <!-- 打包发送到rabbitmq -->
    <bean id="packFactory"
        class="net.neoremind.fountain.consumer.output.pack.impl.ThreadCachedRepeatablePackFactory">
        <property name="factory">
            <bean
                class="net.neoremind.fountain.consumer.output.pack.impl.BigpipePackProtocolFactory">
                <property name="converter">
                    <bean
                        class="net.neoremind.fountain.consumer.output.pack.impl.ChanageDataSet2PbDataConverter" />
                </property>
                <property name="maxBufferSize" value="${pack_buff_size}"></property>
            </bean>
        </property>
    </bean>
    <bean id="rabbitPackOutput"
        class="net.neoremind.fountain.consumer.output.mq.rabbit.RabbitPackedOutput">
        <property name="rabbitSender">
            <bean
                class="net.neoremind.fountain.consumer.output.mq.rabbit.RabbitSender"
                init-method="init">
                <property name="rabbitTemplate" ref="rabbitTemplate"></property>
            </bean>
        </property>
    </bean>
    <bean id="outputSender"
        class="net.neoremind.fountain.consumer.output.pack.PackSupportOutputSender"
        init-method="init" destroy-method="destroy">
        <property name="packFactory" ref="packFactory"></property>
        <property name="output" ref="rabbitPackOutput"></property>
        <property name="bridge" ref="disposeEventPositionBridge"></property>
    </bean>
    <bean id="sendToRabbitConsumer"
        class="net.neoremind.fountain.consumer.output.mq.OutputBinlogTraceable2MQConsumer">
        <!-- use memq时需要设置本属性 -->
        <property name="outputSender" ref="outputSender"></property>
    </bean>
    <!-- 最终消费、使用变化数据的流程,内置缺省实现是DefaultConsumerWorkflow,它需要 unPackProtocol和Consumer接口实现,使用方可以 
        通过实现ConsumerWorkflow接口来实现自己的消费流程,此时实现Consumer接口就不是必要的 -->
    <bean id="consumerWorkflowFromMemMQ"
        class="net.neoremind.fountain.consumer.spi.def.DefaultConsumerWorkflow">
        <!-- <property name="recievedDataConverter" ref=""></property> -->
        <property name="consumer" ref="sendToRabbitConsumer"></property>
    </bean>

    <bean id="fountainMQMessageListener"
        class="net.neoremind.fountain.consumer.support.fountainmq.FountainMQMessageListener"
        init-method="start" destroy-method="destroy">
        <property name="fmq" ref="fountainMQ" />
        <property name="workflow" ref="consumerWorkflowFromMemMQ"></property>
    </bean>
    <!-- 配置数据源和数据监控器,它们成对出现,数据监控器称之为fountain-producer,每个fountain-producer绑定一个数据源, 
        一般数据源是ha数据源。每个fountain-producer是一个线程。如果有多个数据源，可以配置多个配置数据源和数据监控器对 -->
    <!-- 配置需要监控的mysql数据源,支持ha,可以定制多个具体的数据源,一般定制2个,一主一备 -->
    <bean id="groupIdHAMysqlBinlogDataSource00"
        class="net.neoremind.fountain.producer.datasource.ha.HAMysqlBinlogDataSource"
        init-method="init">
        <property name="disposeEventPosition" ref="disposeEventPosition"></property>
        <property name="extender" ref="groupExtender"></property>
        <property name="datasourceChoosePolicy">
            <bean
                class="net.neoremind.fountain.datasource.RoundRobinDatasourceChoosePolicy">
                <property name="tryInterval" value="3000"></property>
            </bean>
        </property>
        <property name="mysqlDataSourceList">
            <list>
                <bean
                    class="net.neoremind.fountain.producer.datasource.MysqlBinlogDataSource">
                    <property name="conf">
                        <bean
                            class="net.neoremind.fountain.datasource.DatasourceConfigure">
                            <property name="mysqlServer"
                                value="${mysql_shard_0_server}"></property>
                            <property name="mysqlPort"
                                value="${mysql_shard_0_port}"></property>
                            <property name="waitTimeout" value="${mysql_wait_timeout}" />
                            <property name="netWriteTimeout" value="${mysql_net_write_timeout}" />
                            <property name="netReadTimeout" value="${mysql_net_read_timeout}" />
                            <property name="charset" value="${mysql_charset}"/>
                            <property name="userName" value="${mysql_username}"></property>
                            <property name="password" value="${mysql_password}"></property>
                        </bean>
                    </property>
                    <property name="gtId" value="${mysql_shard_0_gtId}"></property>
                    <property name="slaveId" value="${mysql_shard_0_slaveId}"></property>
                </bean>
                <bean
                    class="net.neoremind.fountain.producer.datasource.MysqlBinlogDataSource">
                    <property name="conf">
                        <bean
                            class="net.neoremind.fountain.datasource.DatasourceConfigure">
                            <property name="mysqlServer"
                                value="${mysql_shard_0_ha1_server}"></property>
                            <property name="mysqlPort"
                                value="${mysql_shard_0_ha1_port}"></property>
                            <property name="waitTimeout" value="${mysql_wait_timeout}" />
                            <property name="netWriteTimeout" value="${mysql_net_write_timeout}" />
                            <property name="netReadTimeout" value="${mysql_net_read_timeout}" />
                            <property name="charset" value="${mysql_charset}"/>
                            <property name="userName" value="${mysql_username}"></property>
                            <property name="password" value="${mysql_password}"></property>
                        </bean>
                    </property>
                    <property name="gtId" value="${mysql_shard_0_gtId}"></property>
                    <property name="slaveId"
                        value="${mysql_shard_0_ha1_slaveId}"></property>
                </bean>
            </list>
        </property>
    </bean>
    <!-- 监控mysql数据变化的监控器,称之为fountain-producer -->
    <bean id="producer00" class="net.neoremind.fountain.producer.DefaultProducer"
        init-method="start" destroy-method="destroy">
        <!-- 事务控制器,缺省使用net.neoremind.fountain.producer.dispatch.transcontrol.NonTransactionPolicy,
            他不是没事务,而是事务不完整,当一个event的数据解析完后就下发,一个event只是事务中一张表或一张表的部分数据. 一个完成的事务可能是多张表 -->
        <property name="transactionPolicy" ref="miniransPolicy"></property>
        <!-- 绑定要监控的数据源 -->
        <property name="dataSource" ref="groupIdHAMysqlBinlogDataSource00"></property>
        <!-- 数据解析器 -->
        <property name="parser" ref="defaultParser"></property>
        <!-- event 匹配器 -->
        <property name="matcher" ref="shardTableMatcher"></property>
        <!-- 配置数据下发,支持多个下发, 每个下发支持不同的下发流程 -->
        <property name="dispatcher" ref="dispatchWorkflow" />
    </bean>

</beans>